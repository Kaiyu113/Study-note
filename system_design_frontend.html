Facebook News Feed
<!-- 
    Requirement
        General requirement
        Specific requirement
    Component Architecture
    Data Model
    Data Model
    Data Store
    Infinite scroll
    Optimization
    Accessiblity
 -->
Requirement
<!-- 
General requirement
    infinit Scrollable news feeds where stories appears based on user subscribtion
    user can share story
    user can post story and attach comment and images and video

Specific requirement
    We want the feature access by range of device
    We want the feature to be accesible for people with disabilities
 -->
Component Architechture
<!-- 
    Start with a simply UI
    Individual Story component: icon+personal information(name/address), Content(text/image), Control Panel(like, repost, comment)
    Comment list: Icon, comment, comment like, comment input for current user
                   New Feed
                     Story
Story Card        Comment List      Comment Input
                    Comment
-->
Data Model
<!-- 
    Story:{
        id: number,
        comments: comment[],
        media: Media[],
        Date: number,
        Content: String
        origin:{
            userName:
            id:
            type:
            ..data
        }
    }
    comment:{
        id: number,
        author: comment,
        media: Media,
        Date: number,
        Content: String
    }
    Media:{
        type: "link"|| "vedio"
        url: string
    }
 -->
Api Model
<!-- 
           Http1                                      Http2
     limit connection                               multiplexing
     sync block queue                            multi connection
     return plain text                            return rich media
explicity need o close the connection             parallel request
     1TCP send one data                         1TCP send multiple data
                                        compress better, fast connection overall

    
    1. getPost(api_ke//provide the access for the Api, user_id, excludeComments//flag If dont want comment,timestamp//curosr, pageSize, minId//minimal id we want to fetch)
    2. creatPost(api_key, user_id, post_data)
    3. creatComment(api_key, user_id, post_id, comment_data)
    4. subscribeNewStories
     API protocol(we can choose one from those two)
        REST/polling/long polling
            more scalable, rest of http archtecture like caching technique by default
            pro:easy load balance/simple/HTTP2 compatibility
            con:longer latency/connection timeout/traffic overhead
        GRAPHQL
            good for multilevel data, we can easily select what client need,manage the cache by itself
            pro:mordern API/easy load balance/pull the data you need/HTTP2 compatiblity/type safe
            con:longer latency/connection timeout/traffic overhead
        WebSockets
            pro:bidirectional communication/speed real time/single TCP connection
            con:harder to load balance/resourse intensive(because it not http request)/Firewall issue(because it not http request)
            usecase:chat
        SSE(Server Side Event)
            pro:http2/efficent/easy load balance
            con:undirectional/limited data type,mainly text/server to client convo only/hard to use


 -->
Data Store
<!-- 
                  New Feed//fetching point => put and orgnize(flatten the data, we don't want multi layer data) the data in store
                    Story
                     |feed_id
         |feed_entity   |comments            
Story Card        Comment List      Comment Input
                        |comment
                   Comment 

Store:{
    app:{
        user:User,
        setting: UserSetting
        feed:Feed
    }
    Feed:{
        Items:List[FeedItem],
        page:int,
        size:int
    },
    FeedItem:{
        type:FeedItemType,
        createDate:String,
        author:User,
        content:FeedItemContent
        comments:List[FeedItemComment]
    }
    User:{
        name:string,
        ...
    },
    userSetting:{
        timeZone:string,
        AccessibilityPerf:{},
        ...
    }
    FeedItemContent:{
        Title:StyledText,//can contain @ mentions, contain links
        Body:StyledText,
        Media:Media
    }
    Media:{[feed_id]: media},
    entityStore:{[feed_id]: entity},
    commentStore{[feed_id]: cm},
}

Edge Case
    Load new story
        Long polling    
            setInterval, fetch new story every 20 sec
                //Traffic overhead,because long polling is a //full request
                // longer latency,espacially for mobile which use he network cells
        Web-sockets
                //bidirectional data transferring very fast in real time//full request
                //not support http2 protocol
        server side event
                //we subscribe for the events on the server, get udpate in a binary format
                //work under  HTTP protocol
                //fast speed, only load the piece we need in binary format//we can parse it very easily without overhead
                //easy to load balance relatively to websocks
                //latency compare to websockets is only 60milliseconds which is fine for us

-->
Infinite scroll
<!-- 
iff rech the sentinel call api load more//when fetching, creat affect of loading
    Top sentinel
        10 stories
    bottom sentinel
 -->
Optimization
<!-- 
    Network Perfermence/Network layer
        Compression headers: Algorithms used to reduce the size of files transmitted over the network
            Gzip || brottle(newer/google created):
            compression algorithms used to reduce the size of files transmitted over the network, thereby improving network performance and optimizing frontend system design.
        Image optimization   
            size matter
                dimension minimum
            compression & image optimization
                less color data, it will look less vibrate
            webp 
                if the browser support webp use webp
                place holder: show the loader, make a psychological suggestion for user about time files faster
            lazy load
            image microservice in backend:pull compressed image by fixed size
                    story < = optimized imgae= image optimize service < = image url+viewport = story
            CDN: content delivery network ex: aws cloud front/couldfare
                get the asset from the most closer location, to reduce the latency
                cache these image inside enter the caching CDN insert this from the CDN
                srcSet ship different images depending on the device
        Switch to HTTP2
            Multiplexing
                solve the problem in HTTP1,which have five connections at max.
                can load hundreds of resources in parallel
        Bundle Splitting
                Lasy load: split as Feed, Header, Vendor Libraries, Analystics Scripts
                    we can simplify the loading process, we can load all the resources at once
        Caching Strategies
                both server and client can cache some date make it more prefermance
                    Apollo caching, buildin graphql: if receiving same request,set a time like 1hr 
                    batch request/group request if possible: example, collect all the tracking the cache and send it once
                    
    Rendering Perf
        Mbile Friendly
            media queries CSS+responsive
            Flexible Images and Media
            Using Responsive Frameworks
            Responsive Typography & image
        Prevent race condition in your code(concurrent request)
            example: stock trading, large data flow, make sure the data is correct
            avoice duplication
        application Cache
            smart caching strategies, local storage, session storage, cookie
        Providing SSR(server-side-rendering) for some pages
            next.js
            prerender some feeds(css, images),so we don't block whole rendering
        Handle loading/success/Error state
            psychologically change how time files
        Inline critical styles/Script
            serve inside html first  
        Load scripts async || defer non-critical resource
            focus on above folder content first
            so they do not block initial render
                CSS class naming strategy
        CSS class naming strategy
            have multi-level selectors is not good
        TTI-Time to interact
            FCP first content paint
            log network request start and end
            log when component rendered with data
            it ready to use
        Tree shaking
            eliminated dead code
            remove unused bundles
        Virtualization
            no Long list, replace the nodes rather than adding new ones

        
    Javascript Perf
        do less stuff
        do stuff async
        cache result
            if we have heavy stuff
        web workers
            cache the whole stuff for heavy weight job

        PWA mode(flight mode)
            Service Worker & Application Cache
                feed.js
                feed.css
                Story Data
                Image   
        rate limit
            Debounce/throttle
  -->
Accessibility & Security
<!-- 
        ARIA Roles and Properties
        Keyboard Navigation
        Focus Management
        Descriptive Labels
      Support different color schema - for people with color blindness
      All inputs and textareas and other elements should have aria-label
      Internationalization
      Napkin Math
      Image also need to have alt atributes

      Rem font size, more responsive
      cross device testing for compatibility
      proper contrast for 
      Keybroad navigation
      HTML5 sematic tag

    * Preloading: Preload the next card in the background while the user is viewing the current card to make transitions smoother.
    * Offline Mode: If possible, allow users to cache a subset of cards for offline use.
    * Animation and Feedback: Use smooth animations and provide instant feedback on button clicks to enhance user interaction.
    This approach balances performance and user experience, ensuring the app remains responsive even with a large dataset.



      Hot Keys:
        New Story
        Post Story
        Scroll Down
        Scroll top
        Call for help
        Return to main menu
        Sharing options
    
    internationalization
        Use i18n libraries: 
            Implement libraries such as react-i18next, FormatJS, or polyglot.js to handle translations efficiently.
        Resource Bundles: 
            for each language and locale.
        Avoid Hardcoding Strings: 
            Always use variables for translatable text instead of hardcoding strings in the UI.
        Dynamic Formatting: 
            Ensure that date, time, currency, and numeric formatting is locale-aware (e.g., using Intl.DateTimeFormat or Intl.NumberFormat).
        Responsive Design: 
            Account for text expansion, as some languages require more space. For instance, German text tends to be longer than English.
        Text Direction: 
            Support both left-to-right (LTR) and right-to-left (RTL) languages (like Arabic and Hebrew). This involves setting appropriate dir attributes and ensuring your CSS and layout are flexible enough to handle both.
        Cultural Differences: 
            Localize images, icons, and colors if needed. Some symbols or gestures may have different meanings in different cultures.
        Time Zones and Calendars: 
            Make sure that the system can handle different time zones and calendar systems (e.g., Hijri, Buddhist).
        Input Forms: 
            Support various formats for addresses, phone numbers, and postal codes, which differ between countries.
        Language Fallback: 
            Implement language fallback mechanisms to ensure the system defaults to a safe language (usually English) if the translation is missing.
        User Preferences:
            Language Selector: Provide users the ability to choose their preferred language and save this preference.
            Accessibility: different regions with different accessibility standards (e.g., consider screen readers and localized text-to-speech).
            By focusing on these principles, you can create a system that scales well across different languages and locales, providing a smooth experience for global users.

Security
    Cors can only access from specific domin
    rate limiting
    XSS： bad people inject their own javascript in you webpage
        sanitize input: remove js to send to the database
        never render html/js from userdatabase
 -->
Design Pattern 
<!-- 
Creational Patterns/object creation mechanisms.
    Singleton
        Ensures a class has only one instance and provides a global point of access to that instance.
            Example: A configuration manager class that loads settings only once and provides global access.
    Factory 
        Defines an interface for creating objects, but lets subclasses alter the type of objects that will be created.
            Example: A shape factory that can create instances of different shapes like circles, squares, etc.
    Abstract Factory
        Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
            Example: A UI toolkit that can create consistent widgets for different operating systems (Windows, macOS).
    Builder
        Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
            Example: A meal builder in a restaurant system that can construct different types of meals (vegetarian, non-vegetarian).
    Prototype
        Allows cloning of objects, even complex ones, without coupling to their specific classes.
            Example: A graphic design software that clones a shape or an object.
Structural Patterns/deal with object composition or the structure of classes.
    Adapter
        Allows incompatible interfaces to work together by wrapping an existing class with a new interface.
            Example: A legacy payment processing system integrated with a modern payment gateway.
    Bridge: 
        Decouples an abstraction from its implementation, allowing the two to vary independently.
            Example: A remote control system that can work with different devices like TVs, audio systems.
    Composite
        Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.
            Example: A file system where files and directories are treated uniformly.
    Decorator:
        Adds behavior to objects dynamically without affecting the behavior of other objects from the same class.
            Example: Adding different types of borders to a text box in a UI.
    Facade: 
        Provides a simplified interface to a complex subsystem.
            Example: A single interface for a complex library system that manages books, patrons, and loans.
    Flyweight: 
        Reduces memory consumption by sharing as much data as possible with similar objects.
            Example: A text editor that uses flyweight objects for character styling.
    Proxy: 
        Provides a surrogate or placeholder for another object to control access to it.
            Example: A security proxy that checks permissions before allowing access to a resource.
Behavioral Patterns/These patterns deal with communication between objects.
    Chain of Responsibility: 
        Passes a request along a chain of handlers, allowing any handler to process the request.
            Example: A logging system where logs are passed through multiple handlers (e.g., console, file, database).
    Command: 
        Encapsulates a request as an object, allowing for parameterization and queuing of requests.
            Example: A text editor where each operation (cut, copy, paste) is represented as a command.
    Interpreter: 
        Defines a grammatical representation for a language and an interpreter to interpret sentences in the language.
            Example: A simple calculator that interprets and evaluates mathematical expressions.
    Iterator: 
        Provides a way to access elements of a collection without exposing its underlying representation.
            Example: Iterating over a list or array in a collection framework.
    Mediator: 
        Reduces direct communication between objects by having them communicate through a mediator.
            Example: A chat room that manages communication between users.
    Memento: 
        Captures and externalizes an object's internal state so that it can be restored later.
            Example: Undo functionality in text editors.
    Observer: 
        Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.
            Example: A subscription service where subscribers are notified of updates.
    State: 
        Allows an object to alter its behavior when its internal state changes.
            Example: A traffic light system that changes behavior based on its state (green, yellow, red).
    Strategy: 
        Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
            Example: A sorting algorithm where different strategies (bubble sort, quick sort) can be used interchangeably.
    Template Method: 
        Defines the skeleton of an algorithm, deferring some steps to subclasses.
            Example: An application framework where specific steps can be customized by subclassing.
    Visitor: 
        Separates an algorithm from the object structure it operates on, allowing new operations to be added without modifying the structure.
            Example: A file system where different operations (e.g., calculate size, check permissions) can be performed on files and directories.

-->
OOD
<!-- ... -->
Software Development Life Cycle (SDLC)
<!-- 
    1. Requirement analysis
	2. Design
	3. Implementation (coding)
	4. Testing
	5. Documentation (reference & API)
	6. Deployment
	7. Maintaining
 -->
storage
<!-- 
cookie storage
    4kb
    both server and client side: can share token and authenticate info
local storage
    persisted forever
    application state
session
    temp: tab browser window
    form input and so on -->
webpack || vite : 
<!-- build tools clientside rendering performance
    polyfill
        look for different of browser and support fill in, for example if don't have promise, it will ass promise in your code
    compression
            javascript file to gzip file
                increase loading time
            uglify minification
                replace long name to short
            source map
                debug, find the source in production 
    code splitting
        lazyloading
            Only load a small subset of cards (e.g., 10-20) around the current card index at a time.
            As the user navigates, load the next set of cards while discarding those far from the current index.
-->
maintain code quality in large scale codebase
<!-- 
    linting:check for protencial error
        perettier: format
        a11y: all users, including those with disabilities, can effectively use and navigate your website or application
    unitest 
    dependcy scan
    lighthouse: check prefermence after your code change
    Google Lighthouse is ideal for auditing and optimizing performance during development. It’s lightweight, automated, and gives precise recommendations but doesn’t provide continuous real-time monitoring.
    Splunk is a full-scale, real-time monitoring and logging tool that offers end-to-end visibility across an application’s stack, making it more suitable for ongoing operational monitoring and error tracking in production environments.

Using both tools can be complementary: Lighthouse for initial development checks and Splunk for continuous monitoring in production.
-->
Micro frontend
<!-- 
pro: sapreate frontend team and front end component to different domain, and you can deploy it sepreate. fast pace
con: you need large scale
    hard to manage
-->
other
<!-- 
Essential state
    minimum set of state required txo determine the UI's output.
Derived state 
    information that can be computed from the essential state. 

PWA (Progressive Web App)
    web application that uses modern web technologies and design patterns to deliver a user experience comparable to native apps.
        Offline Capabilities
        App-like Experience: with smooth animations and navigation.
        Responsiveness: work on a variety of devices and screen sizes.
        Installation: Users can "install" a PWA to their home screen
        Push Notifications: similar to native apps.
    Example: STARBUCK, PINTEREST,TINDER
CRM (Customer Relationship Management)
    Customer Data Management: Centralized storage and management of customer information.
    Sales Automation: Tools to streamline sales processes, track leads, and manage pipelines.
    Marketing Automation: Features for managing marketing campaigns, segmenting customers, and automating repetitive tasks.
    Customer Service: Tools for managing customer support tickets, live chat, and service inquiries.
    Analytics and Reporting: Capabilities to generate reports and analyze data for better decision-making
    -->
HTTP
<!-- 
1. GET
    Retrieve data from a server.
    Safe: Yes, as it does not modify any resources.
2. POST
    Usage: Used to send data to the server to create/update a resource. It often results in a change on the server, such as creating a new record.
    Safe: No, it modifies resources on the server.
3. PUT
    Used to send data to the server to update a resource. It typically replaces the entire content of the resource.
    Safe: No, as it modifies resources.
4. PATCH
    Similar to PUT, but used when only a partial update is needed, rather than replacing the entire resource.
    Safe: No, as it modifies resources.
5. DELETE
    Used to delete a resource identified by a URL.
    Safe: No, as it removes resources.
 -->
framework& api
<!-- 
Angular: 
    Best suited for large-scale enterprise applications where a comprehensive, opinionated framework with built-in features is beneficial.
React(is a library not framework): 
    Ideal for applications that require flexibility and performance optimization. React’s component-based architecture and extensive ecosystem offer great power and adaptability.
Vue.js: 
    Great for projects needing a balance of simplicity and functionality. Vue’s progressive framework approach and easy learning curve make it suitable for a wide range of applications.
Next.js
    Automatic Code Splitting bundle 
        optimize web applications by loading only the necessary JavaScript for the page being accessed. 
        This feature is especially valuable in improving performance, 
    specific structure and set of conventions for organizing your application. 
        e.g., the pages directory for routing, the public directory for static assets and provides built-in solutions for routing, data fetching, and more.
    Built-in Routing:
        powerful routing system out of the box. Unlike React, where routing is typically handled by external libraries like React Router
        uses file-based routing, where each file in the pages directory automatically corresponds to a route in the application.
    Server-Side Rendering (SSR) and Static Site Generation (SSG):
        built-in support for server-side rendering and static site generation. 
        It allows developers to pre-render pages at build time (SSG) or on each request (SSR)
            Server-Side Rendering ssr
                web server generates the HTML content for a web page and sends it to the client (typically a browser). 
            client-side rendering csr
                browser generates the HTML using JavaScript after receiving an initial empty HTML shell and JavaScript files from the server.
        providing a more optimized and performant user experience.
    API Routes:
        API routes, allowing developers to build API endpoints directly within the application. 
        This feature enables easy creation of serverless functions and backend logic alongside the frontend code.
    Full-Stack Capabilities:
        API routes, SSR, and SSG, Next.js can be used to build full-stack applications. It supports both client-side and server-side logic, offering a more compawwe solution compared to a library like React, which is primarily client-side.
    Middleware and Plugins:
        authentication, data fetching, and more. ustom server implementations, internationalization, and analytics.
    Development and Deployment Tools:
        fast refresh, built-in support for CSS and Sass) and deployment (e.g., static export, Vercel integration). 
        These tools streamline the development workflow and make it easier to deploy applications.

Observable Lifecycle:
    Creation: Observables are created using functions provided by reactive libraries like RxJS.
    Subscription: Observers subscribe to observables to receive the emitted values or events.
    Unsubscription: Observers can unsubscribe to stop receiving values and clean up resources.
    -->
Testing
<!-- 
Unit Tests
    Single unit/component in isolation
    Verify the correctness of individual unit
    Uses mocks/stubs to isolate the unit being tested
    Fine-grained, focusing on small code units
    Tests specific functionalities or logic
    Generally fast
    Tools: 
        Jest (with React Testing Library), Enzyme, and Cypress (although Cypress can also be used for E2E testing).

Integration Tests
    Interaction between multiple components or systems
    Ensure integrated components work together correctly
    Tests real interactions between components or systems
    Tests overall system integration and workflows 
    Tools: 
        Jest (with React Testing Library), Enzyme, and Cypress (although Cypress can also be used for E2E testing).

End to End testing
    E2E testing aims to verify the entire application flow, from the user interface down to the backend systems, 
    as if a real user were interacting with the application. It tests the application in a production-like environment, ensuring that all components and systems work together seamlessly.
    User Scenarios: Simulates user behavior by interacting with the application through the UI, such as clicking buttons, filling out forms, and navigating between pages.
    Full System Validation: Involves testing the complete system, including front-end, back-end, databases, and external services, to ensure that all parts of the application work together as intended.
    Cross-Browser and Device Testing: Can also involve checking that the application works correctly across different browsers and devices.
    Tools: 
        Cypress, Selenium, Playwright, and Puppeteer.   
-->
JS & TS
<!-- 
JavaScript 
    is a flexible, dynamically typed language that is universally used for web development. 
    It’s easy to start with but can lead to challenges in maintaining larger codebases due to its lack of type safety and runtime error detection.
TypeScript 
    builds on JavaScript by adding static types, 
    improving code quality, maintainability, and developer experience. 
    It requires an additional compilation step but provides better tooling and error checking.
-->
internet basic
<!--
url type browser? 
	1. Request a record from computer’s local DNS cache
	2. The browser checks the cache for a DNS record to find the corresponding IP address of maps.google.com.
    3. If the requested URL is not in the cache, ISP’s DNS server initiates a DNS query to find the IP address of the server that hosts maps.google.com.
    4. The browser initiates a TCP connection with the server.
    5. The browser sends an HTTP request to the webserver.
    6. The server handles the request and sends back a response.
    7. The server sends out an HTTP response.
    8. The browser displays the HTML content (for HTML responses, which is the most common). 
Browser render pages
	1.	The DOM and CSSDOM trees are combined to form the render tree
	2.	Layout computes the exact position and size of each object
	3.	paint: color, transition, scale, anything that is not related to layout 
-->
optimize data
<!-- 
* Server-Side Pagination:
    * If the cards are stored on a server, implement server-side pagination to fetch only the required subset of data as the user navigates. 
* IndexedDB/Local Storage:
    * Store the card data in IndexedDB or local storage if the data needs to persist locally, and fetch from the database as needed.

* Efficient State Management:
    * Use a state management library like Redux or Zustand to manage the card state efficiently. Ensure that only the necessary components re-render when the card index changes.
* Optimization Techniques:
    * Debouncing/Throttling: When navigating through cards quickly, debounce or throttle the function calls to prevent excessive re-renders.
    * Memoization: Memoize heavy computations or components that do not need to re-render with every state change.
    -->
cd/ci
<!-- 
Continuous Integration and Continuous Deployment/Delivery (CI/CD)
    Continuous Integration (CI) 
        automating the integration of code changes from multiple contributors into a shared repository several times a day. 
        automated testing to ensure the codebase remains stable. 
    Continuous Deployment (CD) 
        automatically deploying every change that passes the CI pipeline to production. 
        Continuous Delivery is similar but typically requires manual approval before deployment.
2. CI/CD Pipeline Stages
    Answer: The typical stages in a CI/CD pipeline include:
    Source Control: Code is committed to a version control system (like Git).
    Build: The code is compiled and dependencies are installed.
    Testing: Automated tests are run (unit, integration, and sometimes end-to-end tests).
    Deploy: The code is deployed to a staging environment or directly to production.
    Monitor: The application is monitored for issues, and feedback loops are used to inform the team.
3. Tools for CI/CD
    Jenkins, CircleCI, Travis CI, and GitHub Actions. For instance,
    GitHub Actions is useful for automating workflows directly in your GitHub repository, while 
    Jenkins offers extensive plugins and is highly customizable for more complex pipelines.
4. Benefits of CI/CD
    improves development efficiency by reducing the time it takes to detect and fix issues, 
    automating repetitive tasks like testing and deployment, and allowing faster releases. It also enhances collaboration among teams and ensures that the codebase is always in a deployable state.
5. Handling Failures in the Pipeline
    If a build or test fails, the pipeline should stop immediately, and the failure should be reported back to the development team. 
    The team can then investigate the issue, fix the bug, and push the change, which will automatically trigger the pipeline again. 
    To handle such failures efficiently, it’s important to have good logging and notification systems in place, like Slack integrations or email alerts.
6. Deployment Strategies
    This involves maintaining two identical production environments (blue and green). 
    One is live while th e other is idle. New changes are deployed to the idle environment, and after testing, traffic is switched over to it. The previous environment remains as a backup.
7. CI/CD in Microservices
    microservices architecture, each service typically has its own CI/CD pipeline. This ensures that changes in one service do not affect the others. Each pipeline handles the build, testing, and deployment for its respective microservice, and these pipelines can run in parallel. Additionally, containerization tools like Docker are often used, and orchestration platforms like Kubernetes help manage deployments.
8. Testing in CI/CD
    I ensure that tests cover a range of scenarios, including unit, integration, and end-to-end tests. Tests are automated and run during every build to catch issues early. The test suite should be optimized for both speed and coverage, using mocking and stubbing where necessary to avoid bottlenecks. -->
aws
<!-- 
Amazon S3 (Simple Storage Service):
Static Website Hosting: 
    For static websites (HTML, CSS, JavaScript, images, etc.), 
    S3 can be used to host these files and serve them directly to users. S3 buckets are highly durable and scalable.
CDN Integration: 
    Combine S3 with Amazon CloudFront, 
    a Content Delivery Network (CDN) that caches static content globally to improve performance and reduce latency for users around the world.
Amazon EC2 (Elastic Compute Cloud):
    For dynamic websites, you can deploy the application on EC2 instances. 
    EC2 allows you to run virtual servers in the cloud with full control over the OS, software, and configuration.
Auto Scaling: 
    EC2 Auto Scaling helps ensure that you have the right number of EC2 instances running based on demand, improving performance and optimizing cost.
Elastic Beanstalk: 
    This is a Platform-as-a-Service (PaaS) offering that allows you to deploy and manage applications. Elastic Beanstalk automatically handles deployment, load balancing, scaling, and monitoring.
 -->
SEO
<!-- 
To improve SEO from the frontend:

Optimize Meta Tags and Structure: Ensure unique title tags, meta descriptions, and proper heading hierarchy. Use alt text for images.

Mobile Optimization: Ensure responsive design and use the viewport meta tag for mobile-first indexing.

Improve Page Speed: Minify code, lazy load images, optimize image sizes, use a CDN, and reduce render-blocking resources.

Structured Data: Use schema markup and breadcrumbs to improve search engine understanding.

Clean URL Structure: Create short, descriptive, keyword-rich URLs using hyphens.

Accessibility and Semantic HTML: Use ARIA labels, semantic tags, and ensure accessibility for all users.

Internal Linking: Use descriptive anchor text and maintain a logical link structure.

JavaScript SEO: Implement server-side rendering and ensure content is crawlable by search engines.

Fix 404 Errors: Ensure custom 404 pages and fix broken links regularly.

Core Web Vitals: Optimize for LCP, FID, and CLS to improve user experience.

Use HTTPS: Ensure your site is served securely over HTTPS. 
-->
