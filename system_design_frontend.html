Basic
<!-- 
Kilobyte	1024 Bytes	
Megabyte	1, 024 Kilobytes	
Gigabyte	1, 024 Megabytes	
Terabyte	1, 024 Gigabytes

client -> load balancer -> application server
                                        |
                  aggregator server  aggregator server  aggregator server
                /                       \                               \    \     \
   file storage                 load balancer                            \       \         \
              \               /         |        \                        \         \             \
                cache server    cache server      cache server   <->     BD shard    BD shard ...  BD shard 
-->
General 
<!-- 
Scoping the problem: 
    Don’t make assumptions; Ask clarifying questions to understand the constraints and use cases.
        Define requirement
            ● "Who are our users and what are their needs?""
            ● "What is the exact scope of the problem we’re solving?"
            ● Will users of our service be able to post and follow other people?
            ● Should we also design to create and display user’s timeline?
            ● Will posts contain photos and videos?
            ● Are we focusing on back end only or are we developing front end too?
            ● Will users be able to search posts?
            ● Would there be any push notification for new (or important) posts?
                Then we can determine:
                    Functional requirements (what the system must do)
                    Non-functional requirements (how it should perform: availability/consistency/latency) Stretch/Extended requirements
                    Design questions are mostly open-ended, and they don’t have ONE correct answer, that’s why clarifying ambiguities early in the interview becomes critical.
        Get a rough estimate of scale
            It’s always a good idea to estimate the scale of the system you’re going to design. This would also help later when you’ll be focusing on scaling, partitioning, load balancing and caching.
            ● What scale is expected from the system? Number of total users, number of daily active users, number of new posts, how many followers per user on average, etc.
            ● How much storage would we need? We’ll have different numbers if users can have photos and videos in their posts.
            ● What network bandwidth usage are we expecting? This would be crucial in deciding how would we manage traffic and balance load between servers.
                Example:
                    ● 1 billion total users
                    ● 250 million Daily Active Users (DAU)
                    ● 750 million new posts every day
                    ● Each user has 200 followers (median)
                Storage requirements: 
                        each post = 280 characters     
                        2 bytes to store a character without compression
                        assume we need 30 bytes to store metadata with each post (like ID, timestamp, user ID, etc.).
                    Total storage we would need:
                        750m * (560 + 30) bytes => 412GB/day
                    How many total post-views our system will generate? Let’s assume on average a user visits their timeline two times a day and visits five other people’s pages. On each page if a user sees 20 posts, total post-views our system will generate:
                        250M DAU * ((2 + 5) * 20 posts) => 35B/day
                    Bandwidth estimate:
                        (35B * (560 + 30)bytes) / 86400s => 228MB/s
                    Note: This kind of depth lends itself more to backend heavy roles. You don’t have to go this deep determining impacts of scale, but you can and doing so illustrates a deeper, more mature understanding of system design.
                    
Sketching up an abstract 
        Mock out a basic UI
        Define your data model
            This is where the database(s) will be chosen, as well as block storage for things like photos and videos.
            Defining the data model early will clarify how data will flow among different components of the system.
            Later, it will guide towards data partitioning and management.
                User
                    UserId
                    Name
                    Email
                    CreationDate
                    LastLogin
                    ...
                Post
                    PostId
                    UserId
                    Content
                    PostLocation
                    NumberOfLikes
                    Timestamp
                    ...
                UserFollowers
                    UserId
                    FollowerId
                    ...
                FavoritePosts
                    UserId
                    PostId
                    Timestamp
        Define your APIs
                postContent( userId, postData, postLocation, userLocation, timestamp, ...) 
                viewTimeline( userId, userLocation, maxResult, ...)
                likePost( userId, postId, postedUserId, ...)
        High Level Design
            Draw a block diagram with 5-6 boxes representing core components of your system.
            You should identify enough components that are needed to solve the actual problem from end-to-end.
            Think of this as sketching out your MVP.

                database && file storage => Application server*n => load balancer => client

                    *load balancer: distributes incoming network traffic across multiple servers 
                        to ensure no single server becomes overwhelmed.
                        it helps improve the availability, reliability, and scalability of an application
        Detailed Design
            Dig deeper into these high level components. 
            Think through the challenges presented for each one. 
            You should be able to provide different approaches, their pros and cons, and why would you choose one.
            ● Since we’ll be storing a huge amount of data, 
                how should we partition our data to distribute it to multiple databases? 
                Should we try to store all the data of a user on the same database?
                What issue can it cause?
            ● How would we handle VIP users, who post a lot or follow lots of people?
            ● Since user’s timeline will contain most recent (and relevant) posts, should we try to store our data in such a way that is optimized to scan latest posts?
            ● How much and at which layer should we introduce caches to speed things up?
            ● What components need better load balancing?




Identifying and addressing the bottlenecks
            Try to discuss as many bottlenecks as possible and different approaches to mitigate them.
            ● Is there any single point of failure in our system? What are we doing to mitigate it?
            ● Do we have enough replicas of the data so that if we lose a few servers, we can still serve
            our users?
            ● Similarly, do we have enough copies of different services running, such that a few failures
            will not cause total system shutdown?
            ● How are we monitoring the performance of our service? Do we get alerts whenever critical
            components fail or their performance degrade?
                check challenge break down
    -->
Challenge Break Down
<!-- 
Distributed System Tools Summary
    ❖ Load Balancers
        ➢ Distribution methods
    ❖ Cache
        ➢ Cache coherence/invalidation
    ❖ Gateways
        ➢ Decouples clients from internal services
    ❖ Message Brokers
        ➢ Fault tolerance via decoupling

We need to handle many client connections and many requests from those clients without overwhelming a single server
    Load Balancers
        database*n && file storage => (load balancer) => Application server*n => (load balancer) => web server*n => (load balancer) => client
            ● Load Balancing works to distribute load across multiple resources.
            ● It also keeps track of the status of all the resources while distributing requests.
            ● It can be utilized at various points throughout the system.
            ● It can be achieved by ‘smart clients’, hardware, or hybrid software solutions

We want to limit the number of times we’re fetching data
    Caching
            ● Load balancing helps you scale horizontally across an ever-increasing number of servers, 
            but caching will enable you to make vastly better use of the resources you already have
            ● Caches take advantage of a simple principle: recently requested data is likely to be requested again.
            ● They are used in almost every layer of computing: hardware, operating systems, web browsers, web applications and more.
    Cache Coherence
            If the data is modified in the database, it should be invalidated in the cache, if not, this can cause inconsistent application behavior.
            Solving this problem is known as cache invalidation, there are two basic writing schemes that are used:
            1. Write-through cache: 
                Under this scheme data is written into the cache and the corresponding database at the same time.
            2. Write-back cache: 
                Data is written to cache alone, and completion is immediately confirmed to the client. 
                The write to the permanent storage is done later, after specified intervals or under certain conditions.

We’ve got many types of clients (web/native) and our application handles many types of requests?
How do we provide a simplified point of access for clients?
        Gateway
            Mobile Client  \              /  MicroService1
                            API Gateway   -  MicroService2
            Web Client     /              \  MicroService3

        without the gateway:
            Mobile Client       -  /  MicroService1
                                \  /  MicroService2
            Web Client          \  -  MicroService3

        Pro: Clients don’t invoke specific services, they talk to the same gateway
             Simplifies client API code
             Reduce round trips per request
        Con:
             Deployment schedule of gateway possibly coupled to individual deployments of services

We’ve got a distributed system and there are SO many messages going back and forth between servers on the network
    Message Brokers (Queues)
        Queues are used to effectively manage requests in a large-scale distributed system. 
        They allow us to decouple our processes and distribute/throttle processing load

Our clients are in-house and we need to set up a shared cache or monitor/restrict internet usage
    Proxies
    ● A proxy server is a piece of hardware/software that sits between the client(s) and the internet. 
    It receives requests from clients and relays them to the back end servers over the internet.
    ● Typically, proxies are used to filter or log requests, block sites, provide anonymity, etc.
    ● Another advantage of a proxy server is that its cache can serve a lot of requests.

    client  \
    client  - proxy server -> web -> backend server
    client  /

We need to add security, efficiency, or high availability to our backend
    Reverse Proxies
        ● A reverse proxy server is a piece of hardware/software that 
        typically sits between the internet and the back-end server. 
        It receives requests from clients and relays them to the origin servers.
        ● Typically, reverse proxies are used for 
        load balancing, web acceleration via transforming requests (by adding/removing headers, encrypting/decrypting, or compression), and 
        adding additional security for your back end servers.
        ● Another advantage of a proxy server is that its cache can serve a lot of requests.

            client  \
            client  - proxy server -> web -> reverse proxies -> backend server
            client  /

Databases
        Relational Database
            Relational databases are structured and have predefined schemas
            pro:
                when You need to ensure ACID compliance. Your data is structured and unchanging.
            con: 
                less scalability and processing speed, 
            eg. MySQL, PostgreSQL, and Oracle 
                many e-commerce and financial applications an ACID-compliant database remains the preferred option.

        Non-Relational Database
            con:
                unstructured, distributed and have a dynamic schema
                sacrifice ACID compliance for scalability and processing speed, 
            pro:
                store large volumes of data that often require little to no structure
                Making the most of cloud computing and storage for horizontal scaling.
            eg. NoSQL is useful for rapid development as it doesn’t need to be prepped ahead of time.
            Big data is contributing to a large success for NoSQL databases,
            mainly because it handles data differently than the traditional relational databases. 
            A few popular examples of 
            NoSQL databases are MongoDB, CouchDB, Cassandra, and HBase.
        Sharding
            Data partitioning (also known as sharding) 
                is a technique to break up a big database (DB) into many smaller parts. 
                It is the process of splitting up a DB/table across multiple machines to improve the manageability, performance, availability and load balancing of an application.
            Horizontal partitioning: 
                splitting databases up along ranges of data 
                (zip codes less than 10000 are stored in one instance while those above are stored in another)
            Vertical partitioning: 
                splitting across features 
                (all image and video information is partitioned to one instance while user and follower data is on another)
            Directory partitioning: 
                A loosely coupled approach that abstracts away the partitioning scheme from the DB access code so the scheme can change without impacting your application.
            Sharding does come with challenges around joins and referential integrity 
            (you can’t enforce foreign keys across database instances)
        Redundancy and Replication
            ● Redundancy means duplication of critical data or services with the intention of increased reliability of the system.
            ● Creating redundancy in a system can remove single points of failure and provide backups if needed in a crisis.

        primary server -> failover -> secondary server
        active data -> data replication ->mirrored data
-->

Facebook News Feed
<!--
    step by step
    Requirement
        General requirement
        Specific requirement
    Component Architecture
    Data Model
    Data Model
    Data Store
    Infinite scroll
    Optimization
    Accessiblity
 -->
Requirement
<!-- 
General requirement
    infinit Scrollable news feeds where stories appears based on user subscribtion
    user can share story
    user can post story and attach comment and images and video

Specific requirement
    We want the feature access by range of device
    We want the feature to be accesible for people with disabilities
 -->
Component Architechture
<!-- 
    Start with a simply UI
    Individual Story component: icon+personal information(name/address), Content(text/image), Control Panel(like, repost, comment)
    Comment list: Icon, comment, comment like, comment input for current user
                   New Feed
                     Story
Story Card        Comment List      Comment Input
                    Comment
-->
Data Model
<!-- 
    Story:{
        id: number,
        comments: comment[],
        media: Media[],
        Date: number,
        Content: String
        origin:{
            userName:
            id:
            type:
            ..data
        }
    }
    comment:{
        id: number,
        author: comment,
        media: Media,
        Date: number,
        Content: String
    }
    Media:{
        type: "link"|| "vedio"
        url: string
    }
 -->
Api Model
<!-- 
           Http1                                      Http2
     limit connection                               multiplexing
     sync block queue                            multi connection
     return plain text                            return rich media
explicity need o close the connection             parallel request
     1TCP send one data                         1TCP send multiple data
                                        compress better, fast connection overall

    
    1. getPost(api_ke//provide the access for the Api, user_id, excludeComments//flag If dont want comment,timestamp//curosr, pageSize, minId//minimal id we want to fetch)
    2. creatPost(api_key, user_id, post_data)
    3. creatComment(api_key, user_id, post_id, comment_data)
    4. subscribeNewStories
     API protocol(we can choose one from those two)
        REST/polling/long polling
            more scalable, rest of http archtecture like caching technique by default
            pro:easy load balance/simple/HTTP2 compatibility
            con:longer latency/connection timeout/traffic overhead
        GRAPHQL
            good for multilevel data, we can easily select what client need,manage the cache by itself
            pro:mordern API/easy load balance/pull the data you need/HTTP2 compatiblity/type safe
            con:longer latency/connection timeout/traffic overhead
        WebSockets
            pro:bidirectional communication/speed real time/single TCP connection
            con:harder to load balance/resourse intensive(because it not http request)/Firewall issue(because it not http request)
            usecase:chat
        SSE(Server Side Event)
            pro:http2/efficent/easy load balance
            con:undirectional/limited data type,mainly text/server to client convo only/hard to use


 -->
Data Store
<!-- 
                  New Feed//fetching point => put and orgnize(flatten the data, we don't want multi layer data) the data in store
                    Story
                     |feed_id
         |feed_entity   |comments            
Story Card        Comment List      Comment Input
                        |comment
                   Comment 

Store:{
    app:{
        user:User,
        setting: UserSetting
        feed:Feed
    }
    Feed:{
        Items:List[FeedItem],
        page:int,
        size:int
    },
    FeedItem:{
        type:FeedItemType,
        createDate:String,
        author:User,
        content:FeedItemContent
        comments:List[FeedItemComment]
    }
    User:{
        name:string,
        ...
    },
    userSetting:{
        timeZone:string,
        AccessibilityPerf:{},
        ...
    }
    FeedItemContent:{
        Title:StyledText,//can contain @ mentions, contain links
        Body:StyledText,
        Media:Media
    }
    Media:{[feed_id]: media},
    entityStore:{[feed_id]: entity},
    commentStore{[feed_id]: cm},
}

Edge Case
    Load new story
        Long polling    
            setInterval, fetch new story every 20 sec
                //Traffic overhead,because long polling is a //full request
                // longer latency,espacially for mobile which use he network cells
        Web-sockets
                //bidirectional data transferring very fast in real time//full request
                //not support http2 protocol
        server side event
                //we subscribe for the events on the server, get udpate in a binary format
                //work under  HTTP protocol
                //fast speed, only load the piece we need in binary format//we can parse it very easily without overhead
                //easy to load balance relatively to websocks
                //latency compare to websockets is only 60milliseconds which is fine for us

-->
Infinite scroll
<!-- 
iff rech the sentinel call api load more//when fetching, creat affect of loading
    Top sentinel
        10 stories
    bottom sentinel
 -->
Optimization
<!-- 
    Network Perfermence/Network layer
        Compression headers: Algorithms used to reduce the size of files transmitted over the network
            Gzip || brottle(newer/google created):
            compression algorithms used to reduce the size of files transmitted over the network, thereby improving network performance and optimizing frontend system design.
        Image optimization   
            size matter
                dimension minimum
            compression & image optimization
                less color data, it will look less vibrate
            webp 
                if the browser support webp use webp
                place holder: show the loader, make a psychological suggestion for user about time files faster
            lazy load
            image microservice in backend:pull compressed image by fixed size
                    story < = optimized imgae= image optimize service < = image url+viewport = story
            CDN: content delivery network ex: aws cloud front/couldfare
                get the asset from the most closer location, to reduce the latency
                cache these image inside enter the caching CDN insert this from the CDN
                srcSet ship different images depending on the device
        Switch to HTTP2
            Multiplexing
                solve the problem in HTTP1,which have five connections at max.
                can load hundreds of resources in parallel
        Bundle Splitting
                Lasy load: split as Feed, Header, Vendor Libraries, Analystics Scripts
                    we can simplify the loading process, we can load all the resources at once
        Caching Strategies
                both server and client can cache some date make it more prefermance
                    Apollo caching, buildin graphql: if receiving same request,set a time like 1hr 
                    batch request/group request if possible: example, collect all the tracking the cache and send it once
                    
    Rendering Perf
        Mbile Friendly
            media queries CSS+responsive
            Flexible Images and Media
            Using Responsive Frameworks
            Responsive Typography & image
        Prevent race condition in your code(concurrent request)
            example: stock trading, large data flow, make sure the data is correct
            avoice duplication
        application Cache
            smart caching strategies, local storage, session storage, cookie
        Providing SSR(server-side-rendering) for some pages
            next.js
            prerender some feeds(css, images),so we don't block whole rendering
        Handle loading/success/Error state
            psychologically change how time files
        Inline critical styles/Script
            serve inside html first  
        Load scripts async || defer non-critical resource
            focus on above folder content first
            so they do not block initial render
                CSS class naming strategy
        CSS class naming strategy
            have multi-level selectors is not good
        TTI-Time to interact
            FCP first content paint
            log network request start and end
            log when component rendered with data
            it ready to use
        Tree shaking
            eliminated dead code
            remove unused bundles
        Virtualization
            no Long list, replace the nodes rather than adding new ones

        
    Javascript Perf
        do less stuff
        do stuff async
        cache result
            if we have heavy stuff
        web workers
            cache the whole stuff for heavy weight job

        PWA mode(flight mode)
            Service Worker & Application Cache
                feed.js
                feed.css
                Story Data
                Image   
        rate limit
            Debounce/throttle
  -->
Accessibility & Security
<!-- 
        ARIA Roles and Properties
        Keyboard Navigation
        Focus Management
        Descriptive Labels
      Support different color schema - for people with color blindness
      All inputs and textareas and other elements should have aria-label
      Internationalization
      Napkin Math
      Image also need to have alt atributes

      Rem font size, more responsive
      cross device testing for compatibility
      proper contrast for 
      Keybroad navigation
      HTML5 sematic tag

    * Preloading: Preload the next card in the background while the user is viewing the current card to make transitions smoother.
    * Offline Mode: If possible, allow users to cache a subset of cards for offline use.
    * Animation and Feedback: Use smooth animations and provide instant feedback on button clicks to enhance user interaction.
    This approach balances performance and user experience, ensuring the app remains responsive even with a large dataset.



      Hot Keys:
        New Story
        Post Story
        Scroll Down
        Scroll top
        Call for help
        Return to main menu
        Sharing options
    
    internationalization
        Use i18n libraries: 
            Implement libraries such as react-i18next, FormatJS, or polyglot.js to handle translations efficiently.
        Resource Bundles: 
            for each language and locale.
        Avoid Hardcoding Strings: 
            Always use variables for translatable text instead of hardcoding strings in the UI.
        Dynamic Formatting: 
            Ensure that date, time, currency, and numeric formatting is locale-aware (e.g., using Intl.DateTimeFormat or Intl.NumberFormat).
        Responsive Design: 
            Account for text expansion, as some languages require more space. For instance, German text tends to be longer than English.
        Text Direction: 
            Support both left-to-right (LTR) and right-to-left (RTL) languages (like Arabic and Hebrew). This involves setting appropriate dir attributes and ensuring your CSS and layout are flexible enough to handle both.
        Cultural Differences: 
            Localize images, icons, and colors if needed. Some symbols or gestures may have different meanings in different cultures.
        Time Zones and Calendars: 
            Make sure that the system can handle different time zones and calendar systems (e.g., Hijri, Buddhist).
        Input Forms: 
            Support various formats for addresses, phone numbers, and postal codes, which differ between countries.
        Language Fallback: 
            Implement language fallback mechanisms to ensure the system defaults to a safe language (usually English) if the translation is missing.
        User Preferences:
            Language Selector: Provide users the ability to choose their preferred language and save this preference.
            Accessibility: different regions with different accessibility standards (e.g., consider screen readers and localized text-to-speech).
            By focusing on these principles, you can create a system that scales well across different languages and locales, providing a smooth experience for global users.

Security
    Cors can only access from specific domin
    rate limiting
    XSS： bad people inject their own javascript in you webpage
        sanitize input: remove js to send to the database
        never render html/js from userdatabase
    security we do is data protection by encryption sensitive data between the client and server. 
    On the Cyber Hygiene side, it is important to minimize the data in order to  minimized the data exposure. Input validation also important, we should only allowed sanitized data go to server side. If we not sanitize the data, it might be malicious script that attacker want to implant to server.
 -->
Design Pattern 
<!-- 
Creational Patterns/object creation mechanisms.
    Singleton
        Ensures a class has only one instance and provides a global point of access to that instance.
            Example: A configuration manager class that loads settings only once and provides global access.
    Factory 
        Defines an interface for creating objects, but lets subclasses alter the type of objects that will be created.
            Example: A shape factory that can create instances of different shapes like circles, squares, etc.
    Abstract Factory
        Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
            Example: A UI toolkit that can create consistent widgets for different operating systems (Windows, macOS).
    Builder
        Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
            Example: A meal builder in a restaurant system that can construct different types of meals (vegetarian, non-vegetarian).
    Prototype
        Allows cloning of objects, even complex ones, without coupling to their specific classes.
            Example: A graphic design software that clones a shape or an object.
Structural Patterns/deal with object composition or the structure of classes.
    Adapter
        Allows incompatible interfaces to work together by wrapping an existing class with a new interface.
            Example: A legacy payment processing system integrated with a modern payment gateway.
    Bridge: 
        Decouples an abstraction from its implementation, allowing the two to vary independently.
            Example: A remote control system that can work with different devices like TVs, audio systems.
    Composite
        Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.
            Example: A file system where files and directories are treated uniformly.
    Decorator:
        Adds behavior to objects dynamically without affecting the behavior of other objects from the same class.
            Example: Adding different types of borders to a text box in a UI.
    Facade: 
        Provides a simplified interface to a complex subsystem.
            Example: A single interface for a complex library system that manages books, patrons, and loans.
    Flyweight: 
        Reduces memory consumption by sharing as much data as possible with similar objects.
            Example: A text editor that uses flyweight objects for character styling.
    Proxy: 
        Provides a surrogate or placeholder for another object to control access to it.
            Example: A security proxy that checks permissions before allowing access to a resource.
Behavioral Patterns/These patterns deal with communication between objects.
    Chain of Responsibility: 
        Passes a request along a chain of handlers, allowing any handler to process the request.
            Example: A logging system where logs are passed through multiple handlers (e.g., console, file, database).
    Command: 
        Encapsulates a request as an object, allowing for parameterization and queuing of requests.
            Example: A text editor where each operation (cut, copy, paste) is represented as a command.
    Interpreter: 
        Defines a grammatical representation for a language and an interpreter to interpret sentences in the language.
            Example: A simple calculator that interprets and evaluates mathematical expressions.
    Iterator: 
        Provides a way to access elements of a collection without exposing its underlying representation.
            Example: Iterating over a list or array in a collection framework.
    Mediator: 
        Reduces direct communication between objects by having them communicate through a mediator.
            Example: A chat room that manages communication between users.
    Memento: 
        Captures and externalizes an object's internal state so that it can be restored later.
            Example: Undo functionality in text editors.
    Observer: 
        Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.
            Example: A subscription service where subscribers are notified of updates.
    State: 
        Allows an object to alter its behavior when its internal state changes.
            Example: A traffic light system that changes behavior based on its state (green, yellow, red).
    Strategy: 
        Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
            Example: A sorting algorithm where different strategies (bubble sort, quick sort) can be used interchangeably.
    Template Method: 
        Defines the skeleton of an algorithm, deferring some steps to subclasses.
            Example: An application framework where specific steps can be customized by subclassing.
    Visitor: 
        Separates an algorithm from the object structure it operates on, allowing new operations to be added without modifying the structure.
            Example: A file system where different operations (e.g., calculate size, check permissions) can be performed on files and directories.

-->
OOD
<!-- ... -->
Software Development Life Cycle (SDLC)
<!-- 
    1. Requirement analysis
	2. Design
	3. Implementation (coding)
	4. Testing
	5. Documentation (reference & API)
	6. Deployment
	7. Maintaining
 -->
storage
<!-- 
cookie storage
    4kb
    both server and client side: can share token and authenticate info
local storage
    persisted forever
    application state
session
    temp: tab browser window
    form input and so on -->
webpack || vite : 
<!-- build tools clientside rendering performance
    polyfill
        look for different of browser and support fill in, for example if don't have promise, it will ass promise in your code
    compression
            javascript file to gzip file
                increase loading time
            uglify minification
                replace long name to short
            source map
                debug, find the source in production 
    code splitting
        lazyloading
            Only load a small subset of cards (e.g., 10-20) around the current card index at a time.
            As the user navigates, load the next set of cards while discarding those far from the current index.
-->
maintain code quality in large scale codebase
<!-- 
    linting:check for protencial error
        perettier: format
        a11y: all users, including those with disabilities, can effectively use and navigate your website or application
    unitest 
    dependcy scan
    lighthouse: check prefermence after your code change
    Google Lighthouse is ideal for auditing and optimizing performance during development. It’s lightweight, automated, and gives precise recommendations but doesn’t provide continuous real-time monitoring.
    Splunk is a full-scale, real-time monitoring and logging tool that offers end-to-end visibility across an application’s stack, making it more suitable for ongoing operational monitoring and error tracking in production environments.

Using both tools can be complementary: Lighthouse for initial development checks and Splunk for continuous monitoring in production.
-->
Micro frontend
<!-- 
pro: sapreate frontend team and front end component to different domain, and you can deploy it sepreate. fast pace
con: you need large scale
    hard to manage
-->
other
<!-- 
Essential state
    minimum set of state required txo determine the UI's output.
Derived state 
    information that can be computed from the essential state. 

PWA (Progressive Web App)
    web application that uses modern web technologies and design patterns to deliver a user experience comparable to native apps.
        Offline Capabilities
        App-like Experience: with smooth animations and navigation.
        Responsiveness: work on a variety of devices and screen sizes.
        Installation: Users can "install" a PWA to their home screen
        Push Notifications: similar to native apps.
    Example: STARBUCK, PINTEREST,TINDER
CRM (Customer Relationship Management)
    Customer Data Management: Centralized storage and management of customer information.
    Sales Automation: Tools to streamline sales processes, track leads, and manage pipelines.
    Marketing Automation: Features for managing marketing campaigns, segmenting customers, and automating repetitive tasks.
    Customer Service: Tools for managing customer support tickets, live chat, and service inquiries.
    Analytics and Reporting: Capabilities to generate reports and analyze data for better decision-making
    -->
HTTP
<!-- 
1. GET
    Retrieve data from a server.
    Safe: Yes, as it does not modify any resources.
2. POST
    Usage: Used to send data to the server to create/update a resource. It often results in a change on the server, such as creating a new record.
    Safe: No, it modifies resources on the server.
3. PUT
    Used to send data to the server to update a resource. It typically replaces the entire content of the resource.
    Safe: No, as it modifies resources.
4. PATCH
    Similar to PUT, but used when only a partial update is needed, rather than replacing the entire resource.
    Safe: No, as it modifies resources.
5. DELETE
    Used to delete a resource identified by a URL.
    Safe: No, as it removes resources.
 -->
framework& api
<!-- 
Angular: 
    Best suited for large-scale enterprise applications where a comprehensive, opinionated framework with built-in features is beneficial.
React(is a library not framework): 
    Ideal for applications that require flexibility and performance optimization. React’s component-based architecture and extensive ecosystem offer great power and adaptability.
Vue.js: 
    Great for projects needing a balance of simplicity and functionality. Vue’s progressive framework approach and easy learning curve make it suitable for a wide range of applications.
Next.js
    Automatic Code Splitting bundle 
        optimize web applications by loading only the necessary JavaScript for the page being accessed. 
        This feature is especially valuable in improving performance, 
    specific structure and set of conventions for organizing your application. 
        e.g., the pages directory for routing, the public directory for static assets and provides built-in solutions for routing, data fetching, and more.
    Built-in Routing:
        powerful routing system out of the box. Unlike React, where routing is typically handled by external libraries like React Router
        uses file-based routing, where each file in the pages directory automatically corresponds to a route in the application.
    Server-Side Rendering (SSR) and Static Site Generation (SSG):
        built-in support for server-side rendering and static site generation. 
        It allows developers to pre-render pages at build time (SSG) or on each request (SSR)
            Server-Side Rendering ssr
                web server generates the HTML content for a web page and sends it to the client (typically a browser). 
            client-side rendering csr
                browser generates the HTML using JavaScript after receiving an initial empty HTML shell and JavaScript files from the server.
        providing a more optimized and performant user experience.
    API Routes:
        API routes, allowing developers to build API endpoints directly within the application. 
        This feature enables easy creation of serverless functions and backend logic alongside the frontend code.
    Full-Stack Capabilities:
        API routes, SSR, and SSG, Next.js can be used to build full-stack applications. It supports both client-side and server-side logic, offering a more compawwe solution compared to a library like React, which is primarily client-side.
    Middleware and Plugins:
        authentication, data fetching, and more. ustom server implementations, internationalization, and analytics.
    Development and Deployment Tools:
        fast refresh, built-in support for CSS and Sass) and deployment (e.g., static export, Vercel integration). 
        These tools streamline the development workflow and make it easier to deploy applications.

Observable Lifecycle:
    Creation: Observables are created using functions provided by reactive libraries like RxJS.
    Subscription: Observers subscribe to observables to receive the emitted values or events.
    Unsubscription: Observers can unsubscribe to stop receiving values and clean up resources.
    -->
Testing
<!-- 
Unit Tests
    Single unit/component in isolation
    Verify the correctness of individual unit
    Uses mocks/stubs to isolate the unit being tested
    Fine-grained, focusing on small code units
    Tests specific functionalities or logic
    Generally fast
    Tools: 
        Jest (with React Testing Library), Enzyme, and Cypress (although Cypress can also be used for E2E testing).

Integration Tests
    Interaction between multiple components or systems
    Ensure integrated components work together correctly
    Tests real interactions between components or systems
    Tests overall system integration and workflows 
    Tools: 
        Jest (with React Testing Library), Enzyme, and Cypress (although Cypress can also be used for E2E testing).

End to End testing
    E2E testing aims to verify the entire application flow, from the user interface down to the backend systems, 
    as if a real user were interacting with the application. It tests the application in a production-like environment, ensuring that all components and systems work together seamlessly.
    User Scenarios: Simulates user behavior by interacting with the application through the UI, such as clicking buttons, filling out forms, and navigating between pages.
    Full System Validation: Involves testing the complete system, including front-end, back-end, databases, and external services, to ensure that all parts of the application work together as intended.
    Cross-Browser and Device Testing: Can also involve checking that the application works correctly across different browsers and devices.
    Tools: 
        Cypress, Selenium, Playwright, and Puppeteer.   
-->
JS & TS
<!-- 
JavaScript 
    is a flexible, dynamically typed language that is universally used for web development. 
    It’s easy to start with but can lead to challenges in maintaining larger codebases due to its lack of type safety and runtime error detection.
TypeScript 
    builds on JavaScript by adding static types, 
    improving code quality, maintainability, and developer experience. 
    It requires an additional compilation step but provides better tooling and error checking.
-->
internet basic
<!--
url type browser? 
	1. Request a record from computer’s local DNS cache
	2. The browser checks the cache for a DNS record to find the corresponding IP address of maps.google.com.
    3. If the requested URL is not in the cache, ISP’s DNS server initiates a DNS query to find the IP address of the server that hosts maps.google.com.
    4. The browser initiates a TCP connection with the server.
    5. The browser sends an HTTP request to the webserver.
    6. The server handles the request and sends back a response.
    7. The server sends out an HTTP response.
    8. The browser displays the HTML content (for HTML responses, which is the most common). 
Browser render pages
	1.	The DOM and CSSDOM trees are combined to form the render tree
	2.	Layout computes the exact position and size of each object
	3.	paint: color, transition, scale, anything that is not related to layout 
-->
optimize data
<!-- 
* Server-Side Pagination:
    * If the cards are stored on a server, implement server-side pagination to fetch only the required subset of data as the user navigates. 
* IndexedDB/Local Storage:
    * Store the card data in IndexedDB or local storage if the data needs to persist locally, and fetch from the database as needed.

* Efficient State Management:
    * Use a state management library like Redux or Zustand to manage the card state efficiently. Ensure that only the necessary components re-render when the card index changes.
* Optimization Techniques:
    * Debouncing/Throttling: When navigating through cards quickly, debounce or throttle the function calls to prevent excessive re-renders.
    * Memoization: Memoize heavy computations or components that do not need to re-render with every state change.
    -->
cd/ci
<!-- 
Continuous Integration and Continuous Deployment/Delivery (CI/CD)
    Continuous Integration (CI) 
        automating the integration of code changes from multiple contributors into a shared repository several times a day. 
        automated testing to ensure the codebase remains stable. 
    Continuous Deployment (CD) 
        automatically deploying every change that passes the CI pipeline to production. 
        Continuous Delivery is similar but typically requires manual approval before deployment.
2. CI/CD Pipeline Stages
    Answer: The typical stages in a CI/CD pipeline include:
    Source Control: Code is committed to a version control system (like Git).
    Build: The code is compiled and dependencies are installed.
    Testing: Automated tests are run (unit, integration, and sometimes end-to-end tests).
    Deploy: The code is deployed to a staging environment or directly to production.
    Monitor: The application is monitored for issues, and feedback loops are used to inform the team.
3. Tools for CI/CD
    Jenkins, CircleCI, Travis CI, and GitHub Actions. For instance,
    GitHub Actions is useful for automating workflows directly in your GitHub repository, while 
    Jenkins offers extensive plugins and is highly customizable for more complex pipelines.
4. Benefits of CI/CD
    improves development efficiency by reducing the time it takes to detect and fix issues, 
    automating repetitive tasks like testing and deployment, and allowing faster releases. It also enhances collaboration among teams and ensures that the codebase is always in a deployable state.
5. Handling Failures in the Pipeline
    If a build or test fails, the pipeline should stop immediately, and the failure should be reported back to the development team. 
    The team can then investigate the issue, fix the bug, and push the change, which will automatically trigger the pipeline again. 
    To handle such failures efficiently, it’s important to have good logging and notification systems in place, like Slack integrations or email alerts.
6. Deployment Strategies
    This involves maintaining two identical production environments (blue and green). 
    One is live while th e other is idle. New changes are deployed to the idle environment, and after testing, traffic is switched over to it. The previous environment remains as a backup.
7. CI/CD in Microservices
    microservices architecture, each service typically has its own CI/CD pipeline. This ensures that changes in one service do not affect the others. Each pipeline handles the build, testing, and deployment for its respective microservice, and these pipelines can run in parallel. Additionally, containerization tools like Docker are often used, and orchestration platforms like Kubernetes help manage deployments.
8. Testing in CI/CD
    I ensure that tests cover a range of scenarios, including unit, integration, and end-to-end tests. Tests are automated and run during every build to catch issues early. The test suite should be optimized for both speed and coverage, using mocking and stubbing where necessary to avoid bottlenecks. -->
aws
<!-- 
Amazon S3 (Simple Storage Service):
Static Website Hosting: 
    For static websites (HTML, CSS, JavaScript, images, etc.), 
    S3 can be used to host these files and serve them directly to users. S3 buckets are highly durable and scalable.
CDN Integration: 
    Combine S3 with Amazon CloudFront, 
    a Content Delivery Network (CDN) that caches static content globally to improve performance and reduce latency for users around the world.
Amazon EC2 (Elastic Compute Cloud):
    For dynamic websites, you can deploy the application on EC2 instances. 
    EC2 allows you to run virtual servers in the cloud with full control over the OS, software, and configuration.
Auto Scaling: 
    EC2 Auto Scaling helps ensure that you have the right number of EC2 instances running based on demand, improving performance and optimizing cost.
Elastic Beanstalk: 
    This is a Platform-as-a-Service (PaaS) offering that allows you to deploy and manage applications. Elastic Beanstalk automatically handles deployment, load balancing, scaling, and monitoring.
 -->
SEO
<!-- 
To improve SEO from the frontend:

Optimize Meta Tags and Structure: Ensure unique title tags, meta descriptions, and proper heading hierarchy. Use alt text for images.

Mobile Optimization: Ensure responsive design and use the viewport meta tag for mobile-first indexing.

Improve Page Speed: Minify code, lazy load images, optimize image sizes, use a CDN, and reduce render-blocking resources.

Structured Data: Use schema markup and breadcrumbs to improve search engine understanding.

Clean URL Structure: Create short, descriptive, keyword-rich URLs using hyphens.

Accessibility and Semantic HTML: Use ARIA labels, semantic tags, and ensure accessibility for all users.

Internal Linking: Use descriptive anchor text and maintain a logical link structure.

JavaScript SEO: Implement server-side rendering and ensure content is crawlable by search engines.

Fix 404 Errors: Ensure custom 404 pages and fix broken links regularly.

Core Web Vitals: Optimize for LCP, FID, and CLS to improve user experience.

Use HTTPS: Ensure your site is served securely over HTTPS. 
-->
